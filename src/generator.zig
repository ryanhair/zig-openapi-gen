const std = @import("std");
const parser = @import("parser.zig");

const Namespace = struct {
    name: []const u8,
    schemas: std.ArrayList(SchemaEntry),
    sub_namespaces: std.StringHashMap(*Namespace),
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator, name: []const u8) *Namespace {
        const ns = allocator.create(Namespace) catch @panic("OOM");
        ns.* = .{
            .name = name,
            .schemas = .{},
            .sub_namespaces = std.StringHashMap(*Namespace).init(allocator),
            .allocator = allocator,
        };
        return ns;
    }

    pub fn deinit(self: *Namespace) void {
        self.schemas.deinit(self.allocator);
        var it = self.sub_namespaces.iterator();
        while (it.next()) |entry| {
            entry.value_ptr.*.deinit();
        }
        self.sub_namespaces.deinit();
        self.allocator.destroy(self);
    }
};

const SchemaEntry = struct {
    name: []const u8,
    value: std.json.Value,
};

pub fn generate(allocator: std.mem.Allocator, spec: std.json.Value, output_dir: std.fs.Dir) !void {
    if (spec != .object) return;

    // 1. Build Namespace Tree
    const root_ns = Namespace.init(allocator, "root");
    defer root_ns.deinit();

    var schemas: ?std.json.Value = null;
    const components = spec.object.get("components");
    if (components != null and components.? == .object) {
        schemas = components.?.object.get("schemas");
    } else {
        schemas = spec.object.get("definitions");
    }

    if (schemas != null and schemas.? == .object) {
        var schema_iter = schemas.?.object.iterator();
        while (schema_iter.next()) |entry| {
            const name = entry.key_ptr.*;
            const schema = entry.value_ptr.*;
            try addToNamespaceTree(root_ns, name, schema);
        }
    }

    // 2. Generate Root File (root.zig)
    var root_file = try output_dir.createFile("root.zig", .{});
    defer root_file.close();

    var root_buffer: [4096]u8 = undefined;
    var root_writer_impl = root_file.writer(&root_buffer);
    const writer = &root_writer_impl.interface;

    try writer.print("// Generated by zig-openapi-gen\n\n", .{});
    try writer.print("const std = @import(\"std\");\n", .{});
    try writer.print("const root = @This();\n\n", .{});

    // Export top-level namespaces
    var ns_iter = root_ns.sub_namespaces.iterator();
    while (ns_iter.next()) |entry| {
        const ns_name = entry.key_ptr.*;
        try writer.print("pub const {f} = @import(\"{s}.zig\");\n", .{ std.zig.fmtId(ns_name), ns_name });
    }

    // Generate Client in root
    try generateClient(spec, writer, allocator);

    // Generate root schemas
    for (root_ns.schemas.items) |schema_entry| {
        try generateSchema(schema_entry.name, schema_entry.value, writer, 0, allocator, spec);
    }

    try writer.flush();

    // 3. Recursively Generate Namespaces
    var ns_iter_rec = root_ns.sub_namespaces.iterator();
    while (ns_iter_rec.next()) |entry| {
        const ns_name = entry.key_ptr.*;
        const ns = entry.value_ptr.*;
        try generateNamespace(ns, output_dir, ns_name, 0, spec);
    }
}

fn addToNamespaceTree(root: *Namespace, full_name: []const u8, schema: std.json.Value) !void {
    var current = root;
    var it = std.mem.splitScalar(u8, full_name, '.');

    // We need to look ahead to see if it's the last part
    var part = it.next();
    while (part) |p| {
        const next_part = it.peek();
        if (next_part == null) {
            // p is the schema name
            try current.schemas.append(root.allocator, .{ .name = p, .value = schema });
            break;
        } else {
            // p is a namespace
            const gop = try current.sub_namespaces.getOrPut(p);
            if (!gop.found_existing) {
                gop.value_ptr.* = Namespace.init(root.allocator, p);
            }
            current = gop.value_ptr.*;
        }
        part = it.next();
    }
}

fn generateNamespace(ns: *Namespace, parent_dir: std.fs.Dir, name: []const u8, depth: usize, spec: std.json.Value) !void {
    // Create the file for this namespace
    var file_path_buf: [256]u8 = undefined;
    const file_path = try std.fmt.bufPrint(&file_path_buf, "{s}.zig", .{name});

    var file = try parent_dir.createFile(file_path, .{});
    defer file.close();

    var file_buffer: [4096]u8 = undefined;
    var file_writer_impl = file.writer(&file_buffer);
    const writer = &file_writer_impl.interface;

    try writer.print("// Namespace: {s}\n\n", .{ns.name});
    try writer.print("const std = @import(\"std\");\n", .{});

    // Import root
    try writer.print("const root = @import(\"", .{});
    var i: usize = 0;
    while (i < depth) : (i += 1) {
        try writer.print("../", .{});
    }
    try writer.print("root.zig\");\n\n", .{});

    // Generate imports for sub-namespaces
    var sub_iter = ns.sub_namespaces.iterator();
    while (sub_iter.next()) |entry| {
        const sub_name = entry.key_ptr.*;
        const camel_name = try toCamelCase(ns.allocator, sub_name);
        defer ns.allocator.free(camel_name);
        // Import path: "name/sub.zig"
        try writer.print("pub const {f} = @import(\"{s}/{s}.zig\");\n", .{ std.zig.fmtId(camel_name), ns.name, sub_name });
    }
    try writer.print("\n", .{});

    // Generate schemas
    for (ns.schemas.items) |schema_entry| {
        try generateSchema(schema_entry.name, schema_entry.value, writer, depth, ns.allocator, spec);
    }

    try writer.flush();

    // Recurse
    if (ns.sub_namespaces.count() > 0) {
        // Create directory for sub-namespaces
        parent_dir.makeDir(ns.name) catch |err| {
            if (err != error.PathAlreadyExists) return err;
        };
        var sub_dir = try parent_dir.openDir(ns.name, .{});
        defer sub_dir.close();

        var sub_iter_rec = ns.sub_namespaces.iterator();
        while (sub_iter_rec.next()) |entry| {
            const sub_name = entry.key_ptr.*;
            const sub_ns = entry.value_ptr.*;
            try generateNamespace(sub_ns, sub_dir, sub_name, depth + 1, spec);
        }
    }
}

fn generateSchema(name: []const u8, schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    if (schema != .object) return;

    // Special handling for IntOrString and Patch
    if (std.mem.eql(u8, name, "IntOrString")) {
        try writer.print("pub const {f} = std.json.Value;\n\n", .{std.zig.fmtId(name)});
        return;
    }
    if (std.mem.eql(u8, name, "Patch")) {
        try writer.print("pub const {f} = std.json.Value;\n\n", .{std.zig.fmtId(name)});
        return;
    }

    if (schema.object.get("enum")) |_| {
        try generateEnum(name, schema, writer);
        return;
    }
    if (schema.object.get("oneOf")) |_| {
        try generateOneOf(name, schema, writer, depth, allocator, spec);
        return;
    }
    if (schema.object.get("allOf")) |_| {
        try generateAllOf(name, schema, writer, depth, allocator, spec);
        return;
    }
    if (schema.object.get("anyOf")) |_| {
        try generateAnyOf(name, schema, writer, depth, allocator, spec);
        return;
    }

    const type_val = schema.object.get("type");
    if (type_val != null) {
        if (std.mem.eql(u8, type_val.?.string, "object")) {
            try generateStruct(name, schema, writer, depth, allocator, spec);
        } else {
            const zig_type = try mapType(type_val.?.string);
            try writer.print("pub const {f} = {s};\n\n", .{ std.zig.fmtId(name), zig_type });
        }
    } else {
        try writer.print("pub const {f} = std.json.Value;\n\n", .{std.zig.fmtId(name)});
    }
}

fn resolveRef(ref: []const u8, current_depth: usize, allocator: std.mem.Allocator) ![]const u8 {
    _ = current_depth;
    // ref is like "#/definitions/io.k8s.api.core.v1.Pod"
    const last_slash = std.mem.lastIndexOf(u8, ref, "/");
    if (last_slash) |idx| {
        const type_full_name = ref[idx + 1 ..];
        // type_full_name is "io.k8s.api.core.v1.Pod"
        // We want "root.io.k8s.api.core.v1.Pod" (with quotes where needed)

        var string_buffer = std.ArrayList(u8){};
        const w = string_buffer.writer(allocator);

        try w.writeAll("root");
        var it = std.mem.splitScalar(u8, type_full_name, '.');
        var parts = std.ArrayList([]const u8){};
        defer parts.deinit(allocator);
        while (it.next()) |part| {
            try parts.append(allocator, part);
        }

        for (parts.items, 0..) |part, i| {
            if (i < parts.items.len - 1) {
                // Namespace part - camelCase
                const camel = try toCamelCase(allocator, part);
                defer allocator.free(camel);
                try w.print(".{f}", .{std.zig.fmtId(camel)});
            } else {
                // Type name part - keep as is (or maybe sanitize?)
                try w.print(".{f}", .{std.zig.fmtId(part)});
            }
        }
        return string_buffer.toOwnedSlice(allocator);
    }
    return allocator.dupe(u8, "void");
}

fn resolveSchema(spec: std.json.Value, ref: []const u8) ?std.json.Value {
    // ref is like "#/components/schemas/User" or "#/definitions/User"
    if (!std.mem.startsWith(u8, ref, "#/")) return null;

    var it = std.mem.splitScalar(u8, ref[2..], '/');
    var current = spec;
    while (it.next()) |part| {
        if (current != .object) return null;
        if (current.object.get(part)) |val| {
            current = val;
        } else {
            return null;
        }
    }
    return current;
}

fn generateEnum(name: []const u8, schema: std.json.Value, writer: anytype) !void {
    try writer.print("pub const {f} = enum {{\n", .{std.zig.fmtId(name)});
    const enum_vals = schema.object.get("enum").?.array;
    for (enum_vals.items) |val| {
        if (val == .string) {
            try writer.print("    {f},\n", .{std.zig.fmtId(val.string)});
        }
    }
    try writer.print("}};\n\n", .{});
}

fn generateOneOf(name: []const u8, schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    _ = spec;
    try writer.print("pub const {f} = union(enum) {{\n", .{std.zig.fmtId(name)});
    const variants = schema.object.get("oneOf").?.array;
    for (variants.items) |variant| {
        if (variant.object.get("$ref")) |ref| {
            const type_path = try resolveRef(ref.string, depth, allocator);
            defer allocator.free(type_path);
            // Extract just the last part for the field name
            const ref_str = ref.string;
            const last_dot = std.mem.lastIndexOf(u8, ref_str, ".");
            var field_name = ref_str;
            if (last_dot) |idx| {
                field_name = ref_str[idx + 1 ..];
            } else {
                // Fallback for no dots
                const last_slash = std.mem.lastIndexOf(u8, ref_str, "/");
                if (last_slash) |idx| {
                    field_name = ref_str[idx + 1 ..];
                }
            }

            try writer.print("    {f}: {s},\n", .{ std.zig.fmtId(field_name), type_path });
        }
    }

    if (schema.object.get("discriminator")) |disc| {
        if (disc.object.get("propertyName")) |prop_val| {
            const prop_name = prop_val.string;
            try writer.print("\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !@This() {{\n", .{});
            try writer.print("        const value = try std.json.Value.jsonParse(allocator, source, options);\n", .{});
            try writer.print("        if (value != .object) return error.SyntaxError;\n", .{});
            try writer.print("        const discriminator = value.object.get(\"{s}\") orelse return error.MissingField;\n", .{prop_name});
            try writer.print("        if (discriminator != .string) return error.SyntaxError;\n", .{});
            try writer.print("        const type_name = discriminator.string;\n", .{});

            for (variants.items) |variant| {
                if (variant.object.get("$ref")) |ref| {
                    const ref_str = ref.string;
                    // Determine expected value and variant name
                    // For now assume value matches variant name (implicit mapping)
                    var variant_name = ref_str;
                    const last_slash = std.mem.lastIndexOf(u8, ref_str, "/");
                    if (last_slash) |idx| {
                        variant_name = ref_str[idx + 1 ..];
                    }
                    const type_path = try resolveRef(ref.string, depth, allocator);
                    defer allocator.free(type_path);

                    try writer.print("        if (std.mem.eql(u8, type_name, \"{s}\")) {{\n", .{variant_name});
                    try writer.print("            const parsed = try std.json.parseFromValue({s}, allocator, value, options);\n", .{type_path});
                    try writer.print("            return @This(){{ .{f} = parsed.value }};\n", .{std.zig.fmtId(variant_name)});
                    try writer.print("        }}\n", .{});
                }
            }
            try writer.print("        return error.InvalidEnumTag;\n", .{});
            try writer.print("    }}\n", .{});
        }
    }

    try writer.print("}};\n\n", .{});
}

fn generateAnyOf(name: []const u8, schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    // Treat anyOf as a union for now, similar to oneOf
    _ = spec;
    try writer.print("pub const {f} = union(enum) {{\n", .{std.zig.fmtId(name)});
    const variants = schema.object.get("anyOf").?.array;
    for (variants.items) |variant| {
        if (variant.object.get("$ref")) |ref| {
            const type_path = try resolveRef(ref.string, depth, allocator);
            defer allocator.free(type_path);
            const ref_str = ref.string;
            const last_dot = std.mem.lastIndexOf(u8, ref_str, ".");
            var field_name = ref_str;
            if (last_dot) |idx| {
                field_name = ref_str[idx + 1 ..];
            } else {
                const last_slash = std.mem.lastIndexOf(u8, ref_str, "/");
                if (last_slash) |idx| {
                    field_name = ref_str[idx + 1 ..];
                }
            }
            try writer.print("    {f}: {s},\n", .{ std.zig.fmtId(field_name), type_path });
        }
    }
    try writer.print("}};\n\n", .{});
}

fn generateAllOf(name: []const u8, schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    try writer.print("pub const {f} = struct {{\n", .{std.zig.fmtId(name)});
    const items = schema.object.get("allOf").?.array;
    for (items.items) |item| {
        if (item.object.get("$ref")) |ref| {
            if (resolveSchema(spec, ref.string)) |resolved| {
                try generateStructProperties(resolved, writer, depth, allocator, spec);
            }
        } else if (item.object.get("type")) |t| {
            if (std.mem.eql(u8, t.string, "object")) {
                try generateStructProperties(item, writer, depth, allocator, spec);
            }
        }
    }
    try writer.print("\n    pub fn validate(self: @This()) !void {{\n", .{});
    var has_constraints = false;
    for (items.items) |item| {
        if (item.object.get("$ref")) |ref| {
            if (resolveSchema(spec, ref.string)) |resolved| {
                if (hasValidationConstraints(resolved, spec)) has_constraints = true;
            }
        } else if (item.object.get("type")) |t| {
            if (std.mem.eql(u8, t.string, "object")) {
                if (hasValidationConstraints(item, spec)) has_constraints = true;
            }
        }
    }
    if (!has_constraints) {
        try writer.print("        _ = self;\n", .{});
    }
    for (items.items) |item| {
        if (item.object.get("$ref")) |ref| {
            if (resolveSchema(spec, ref.string)) |resolved| {
                try generateValidationChecks(resolved, writer, allocator, spec);
            }
        } else if (item.object.get("type")) |t| {
            if (std.mem.eql(u8, t.string, "object")) {
                try generateValidationChecks(item, writer, allocator, spec);
            }
        }
    }
    try writer.print("    }}\n", .{});
    try writer.print("}};\n\n", .{});
}

fn generateStruct(name: []const u8, schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    try writer.print("pub const {f} = struct {{\n", .{std.zig.fmtId(name)});
    try generateStructProperties(schema, writer, depth, allocator, spec);
    try writer.print("\n    pub fn validate(self: @This()) !void {{\n", .{});
    if (!hasValidationConstraints(schema, spec)) {
        try writer.print("        _ = self;\n", .{});
    }
    try generateValidationChecks(schema, writer, allocator, spec);
    try writer.print("    }}\n", .{});
    try writer.print("}};\n\n", .{});
}

fn generateStructProperties(schema: std.json.Value, writer: anytype, depth: usize, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    _ = spec;
    const properties = schema.object.get("properties");
    if (properties != null and properties.? == .object) {
        var prop_iter = properties.?.object.iterator();
        while (prop_iter.next()) |prop_entry| {
            const prop_name = prop_entry.key_ptr.*;
            const prop = prop_entry.value_ptr.*;
            if (prop != .object) continue;

            var zig_type: []const u8 = "[]const u8";
            var is_ref = false;
            var type_buf: [256]u8 = undefined;

            if (prop.object.get("$ref")) |ref| {
                zig_type = try resolveRef(ref.string, depth, allocator);
                is_ref = true;
            } else {
                const type_val = prop.object.get("type");
                if (type_val != null and type_val.? == .string) {
                    if (std.mem.eql(u8, type_val.?.string, "array")) {
                        const items = prop.object.get("items");
                        if (items != null and items.? == .object) {
                            if (items.?.object.get("$ref")) |ref| {
                                const item_type = try resolveRef(ref.string, depth, allocator);
                                defer allocator.free(item_type);
                                zig_type = try std.fmt.bufPrint(&type_buf, "[]const {s}", .{item_type});
                            } else if (items.?.object.get("type")) |t| {
                                if (t == .string) {
                                    const item_type = try mapType(t.string);
                                    zig_type = try std.fmt.bufPrint(&type_buf, "[]const {s}", .{item_type});
                                }
                            }
                        }
                    } else {
                        zig_type = try mapType(type_val.?.string);
                    }
                } else {
                    continue;
                }
            }

            var is_required = false;
            const required = schema.object.get("required");
            if (required != null and required.? == .array) {
                for (required.?.array.items) |req| {
                    if (req == .string and std.mem.eql(u8, req.string, prop_name)) {
                        is_required = true;
                        break;
                    }
                }
            }

            const camel_prop_name = try toCamelCase(allocator, prop_name);
            defer allocator.free(camel_prop_name);

            if (is_required) {
                if (is_ref) {
                    try writer.print("    {f}: {s},\n", .{ std.zig.fmtId(camel_prop_name), zig_type });
                } else {
                    try writer.print("    {f}: {s},\n", .{ std.zig.fmtId(camel_prop_name), zig_type });
                }
            } else {
                if (is_ref) {
                    try writer.print("    {f}: ?{s} = null,\n", .{ std.zig.fmtId(camel_prop_name), zig_type });
                } else {
                    try writer.print("    {f}: ?{s} = null,\n", .{ std.zig.fmtId(camel_prop_name), zig_type });
                }
            }

            if (is_ref) {
                allocator.free(zig_type);
            }
        }
    }

    if (schema.object.get("additionalProperties")) |add_props| {
        if (add_props == .object) {
            // For now, just map to std.json.Value to allow flexibility
            try writer.print("    extraProps: ?std.json.Value = null,\n", .{});
        }
    }
}

fn hasValidationConstraints(schema: std.json.Value, spec: std.json.Value) bool {
    const properties = schema.object.get("properties");
    if (properties != null and properties.? == .object) {
        var prop_iter = properties.?.object.iterator();
        while (prop_iter.next()) |prop_entry| {
            const prop = prop_entry.value_ptr.*;
            if (prop != .object) continue;

            // Check for $ref (nested struct)
            if (prop.object.get("$ref")) |ref| {
                if (resolveSchema(spec, ref.string)) |resolved| {
                    // If the resolved schema has properties, we will generate a validate() call
                    if (resolved.object.get("properties") != null) return true;
                }
            }

            if (prop.object.get("type")) |t| {
                if (t == .string and std.mem.eql(u8, t.string, "string")) {
                    if (prop.object.get("minLength") != null) return true;
                    if (prop.object.get("maxLength") != null) return true;
                }
                if (t == .string and (std.mem.eql(u8, t.string, "integer") or std.mem.eql(u8, t.string, "number"))) {
                    if (prop.object.get("minimum") != null) return true;
                    if (prop.object.get("maximum") != null) return true;
                }
                if (t == .string and std.mem.eql(u8, t.string, "array")) {
                    // Check array items
                    if (prop.object.get("items")) |items| {
                        if (items.object.get("$ref")) |ref| {
                            if (resolveSchema(spec, ref.string)) |resolved| {
                                // If array items are structs, we validate them
                                if (resolved.object.get("properties") != null) return true;
                            }
                        }
                    }
                }
            }
        }
    }
    return false;
}

fn generateValidationChecks(schema: std.json.Value, writer: anytype, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    const properties = schema.object.get("properties");
    if (properties != null and properties.? == .object) {
        var prop_iter = properties.?.object.iterator();
        while (prop_iter.next()) |prop_entry| {
            const prop_name = prop_entry.key_ptr.*;
            const prop = prop_entry.value_ptr.*;
            if (prop != .object) continue;

            const camel_prop_name = try toCamelCase(allocator, prop_name);
            defer allocator.free(camel_prop_name);
            const field_name = std.zig.fmtId(camel_prop_name);

            // 1. Recursive Validation for Nested Structs ($ref)
            if (prop.object.get("$ref")) |ref| {
                if (resolveSchema(spec, ref.string)) |resolved| {
                    if (resolved.object.get("properties") != null) {
                        // It's a struct, call validate()
                        // Check if optional (not in required list)
                        var is_required = false;
                        if (schema.object.get("required")) |req| {
                            for (req.array.items) |r| {
                                if (std.mem.eql(u8, r.string, prop_name)) {
                                    is_required = true;
                                    break;
                                }
                            }
                        }

                        if (is_required) {
                            try writer.print("        try self.{f}.validate();\n", .{field_name});
                        } else {
                            try writer.print("        if (self.{f}) |v| try v.validate();\n", .{field_name});
                        }
                    }
                }
            }

            // 2. Recursive Validation for Arrays
            if (prop.object.get("type")) |t| {
                if (t == .string and std.mem.eql(u8, t.string, "array")) {
                    if (prop.object.get("items")) |items| {
                        if (items.object.get("$ref")) |ref| {
                            if (resolveSchema(spec, ref.string)) |resolved| {
                                if (resolved.object.get("properties") != null) {
                                    // Array of structs
                                    var is_required = false;
                                    if (schema.object.get("required")) |req| {
                                        for (req.array.items) |r| {
                                            if (std.mem.eql(u8, r.string, prop_name)) {
                                                is_required = true;
                                                break;
                                            }
                                        }
                                    }

                                    if (is_required) {
                                        try writer.print("        for (self.{f}) |item| try item.validate();\n", .{field_name});
                                    } else {
                                        try writer.print("        if (self.{f}) |arr| for (arr) |item| try item.validate();\n", .{field_name});
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. Primitive Constraints
            var has_constraints = false;
            if (prop.object.get("type")) |t| {
                if (t == .string and std.mem.eql(u8, t.string, "string")) {
                    if (prop.object.get("minLength") != null) has_constraints = true;
                    if (prop.object.get("maxLength") != null) has_constraints = true;
                }
                if (t == .string and (std.mem.eql(u8, t.string, "integer") or std.mem.eql(u8, t.string, "number"))) {
                    if (prop.object.get("minimum") != null) has_constraints = true;
                    if (prop.object.get("maximum") != null) has_constraints = true;
                }
            }

            if (has_constraints) {
                try writer.print("        if (self.{f}) |val| {{\n", .{field_name});

                if (prop.object.get("type")) |t| {
                    if (t == .string and std.mem.eql(u8, t.string, "string")) {
                        if (prop.object.get("minLength")) |min| {
                            try writer.print("            if (val.len < {d}) return error.ValidationError;\n", .{min.integer});
                        }
                        if (prop.object.get("maxLength")) |max| {
                            try writer.print("            if (val.len > {d}) return error.ValidationError;\n", .{max.integer});
                        }
                    }
                    if (t == .string and (std.mem.eql(u8, t.string, "integer") or std.mem.eql(u8, t.string, "number"))) {
                        if (prop.object.get("minimum")) |min| {
                            try writer.print("            if (val < {d}) return error.ValidationError;\n", .{min.integer});
                        }
                        if (prop.object.get("maximum")) |max| {
                            try writer.print("            if (val > {d}) return error.ValidationError;\n", .{max.integer});
                        }
                    }
                }
                try writer.print("        }}\n", .{});
            }
        }
    }
}

fn generateServers(spec: std.json.Value, writer: anytype, allocator: std.mem.Allocator) !void {
    _ = allocator;
    const servers = spec.object.get("servers");
    if (servers != null and servers.? == .array) {
        try writer.print("pub const Servers = struct {{\n", .{});
        for (servers.?.array.items, 0..) |server, i| {
            const url = server.object.get("url").?.string;
            const desc = if (server.object.get("description")) |d| d.string else "No description";

            try writer.print("    // {s}\n", .{desc});
            try writer.print("    pub const server{d}_url = \"{s}\";\n", .{ i, url });

            if (server.object.get("variables")) |vars| {
                try writer.print("    pub const Server{d}Vars = struct {{\n", .{i});
                var var_it = vars.object.iterator();
                while (var_it.next()) |entry| {
                    const var_name = entry.key_ptr.*;
                    const var_def = entry.value_ptr.*;
                    const default_val = var_def.object.get("default").?.string;
                    try writer.print("        {f}: []const u8 = \"{s}\",\n", .{ std.zig.fmtId(var_name), default_val });
                }
                try writer.print("    }};\n", .{});
            }
        }

        try writer.print("\n    pub fn getUrl(index: usize, vars: anytype, allocator: std.mem.Allocator) ![]const u8 {{\n", .{});
        try writer.print("        switch (index) {{\n", .{});
        for (servers.?.array.items, 0..) |server, i| {
            try writer.print("            {d} => {{\n", .{i});
            if (server.object.get("variables")) |vars| {
                try writer.print("                const default_vars = Server{d}Vars{{}};\n", .{i});
                try writer.print("                var url = try allocator.dupe(u8, server{d}_url);\n", .{i});
                try writer.print("                errdefer allocator.free(url);\n", .{});

                var var_it = vars.object.iterator();
                while (var_it.next()) |entry| {
                    const var_name = entry.key_ptr.*;
                    try writer.print("                {{\n", .{});
                    try writer.print("                    const key = \"{{{s}}}\";\n", .{var_name});
                    try writer.print("                    const val = if (@hasField(@TypeOf(vars), \"{s}\")) @field(vars, \"{s}\") else default_vars.{f};\n", .{ var_name, var_name, std.zig.fmtId(var_name) });
                    try writer.print("                    const new_url = try std.mem.replaceOwned(u8, allocator, url, key, val);\n", .{});
                    try writer.print("                    allocator.free(url);\n", .{});
                    try writer.print("                    url = new_url;\n", .{});
                    try writer.print("                }}\n", .{});
                }
                try writer.print("                return url;\n", .{});
            } else {
                try writer.print("                return try allocator.dupe(u8, server{d}_url);\n", .{i});
            }
            try writer.print("            }},\n", .{});
        }
        try writer.print("            else => return error.InvalidServerIndex,\n", .{});
        try writer.print("        }}\n", .{});
        try writer.print("    }}\n", .{});
        try writer.print("}};\n\n", .{});
    } else {
        try writer.print("pub const Servers = struct {{}};\n\n", .{});
    }
}

fn generateClient(spec: std.json.Value, writer: anytype, allocator: std.mem.Allocator) !void {
    // Generate AuthConfig
    try writer.print("pub const AuthConfig = struct {{\n", .{});
    const components = spec.object.get("components");
    var has_auth = false;
    if (components != null and components.? == .object) {
        if (components.?.object.get("securitySchemes")) |schemes| {
            if (schemes == .object) {
                var it = schemes.object.iterator();
                while (it.next()) |entry| {
                    has_auth = true;
                    const scheme_name = entry.key_ptr.*;
                    // For now, assume all auth tokens are strings
                    try writer.print("    {f}: ?[]const u8 = null,\n", .{std.zig.fmtId(scheme_name)});
                }
            }
        }
    }
    try writer.print("}};\n\n", .{});

    try generateServers(spec, writer, allocator);

    try writer.print("pub const Client = struct {{\n", .{});
    try writer.print("    allocator: std.mem.Allocator,\n", .{});
    try writer.print("    client: std.http.Client,\n", .{});
    try writer.print("    base_url: []const u8,\n", .{});
    try writer.print("    base_url_owned: ?[]const u8 = null,\n", .{});
    try writer.print("    auth_config: AuthConfig,\n\n", .{});

    try writer.writeAll(
        \\    pub fn WatchEvent(comptime T: type) type {
        \\        return struct {
        \\            type: []const u8,
        \\            object: T,
        \\        };
        \\    }
        \\
        \\    pub fn WatchStream(comptime T: type) type {
        \\        return struct {
        \\            allocator: std.mem.Allocator,
        \\            req: *std.http.Client.Request,
        \\            transfer_buf: []u8,
        \\            reader: *std.io.Reader,
        \\            current_line: ?[]u8 = null,
        \\            current_parsed: ?std.json.Parsed(WatchEvent(T)) = null,
        \\
        \\            const Self = @This();
        \\
        \\            pub fn deinit(self: *@This()) void {
        \\                if (self.current_parsed) |*p| p.deinit();
        \\                if (self.current_line) |l| self.allocator.free(l);
        \\                self.req.deinit();
        \\                self.allocator.destroy(self.req);
        \\                self.allocator.free(self.transfer_buf);
        \\            }
        \\
        \\            fn readLine(self: *@This()) !?[]u8 {
        \\                var result = std.ArrayListUnmanaged(u8){};
        \\                errdefer result.deinit(self.allocator);
        \\                while (true) {
        \\                    const buffered = self.reader.buffer[self.reader.seek..self.reader.end];
        \\                    if (std.mem.indexOfScalar(u8, buffered, '\n')) |idx| {
        \\                        try result.appendSlice(self.allocator, buffered[0..idx]);
        \\                        self.reader.seek += idx + 1;
        \\                        return try result.toOwnedSlice(self.allocator);
        \\                    }
        \\                    try result.appendSlice(self.allocator, buffered);
        \\                    self.reader.seek = self.reader.end;
        \\                    self.reader.fillMore() catch |err| switch (err) {
        \\                        error.EndOfStream => {
        \\                            if (result.items.len > 0) return try result.toOwnedSlice(self.allocator);
        \\                            return null;
        \\                        },
        \\                        else => return err,
        \\                    };
        \\                }
        \\            }
        \\
        \\            pub fn next(self: *@This()) !?WatchEvent(T) {
        \\                if (self.current_parsed) |*p| {
        \\                    p.deinit();
        \\                    self.current_parsed = null;
        \\                }
        \\                if (self.current_line) |l| {
        \\                    self.allocator.free(l);
        \\                    self.current_line = null;
        \\                }
        \\
        \\                const line = try self.readLine();
        \\                if (line) |l| {
        \\                    self.current_line = l;
        \\                    const parsed = try std.json.parseFromSlice(WatchEvent(T), self.allocator, l, .{ .ignore_unknown_fields = true });
        \\                    self.current_parsed = parsed;
        \\                    return parsed.value;
        \\                }
        \\                return null;
        \\            }
        \\        };
        \\    }
        \\
    );

    try writer.print("    pub fn init(allocator: std.mem.Allocator, auth_config: AuthConfig, options: anytype) !Client {{\n", .{});
    try writer.print("        var base_url: []const u8 = \"\";\n", .{});
    try writer.print("        var base_url_owned: ?[]const u8 = null;\n", .{});
    try writer.print("        _ = &base_url_owned;\n", .{});
    try writer.print("        var has_base_url = false;\n", .{});
    try writer.print("        if (@hasField(@TypeOf(options), \"base_url\")) {{\n", .{});
    try writer.print("            const val = options.base_url;\n", .{});
    try writer.print("            if (@typeInfo(@TypeOf(val)) == .optional) {{\n", .{});
    try writer.print("                if (val) |v| {{\n", .{});
    try writer.print("                    base_url = v;\n", .{});
    try writer.print("                    has_base_url = true;\n", .{});
    try writer.print("                }}\n", .{});
    try writer.print("            }} else {{\n", .{});
    try writer.print("                base_url = val;\n", .{});
    try writer.print("                has_base_url = true;\n", .{});
    try writer.print("            }}\n", .{});
    try writer.print("        }}\n", .{});
    try writer.print("\n", .{});
    try writer.print("        if (!has_base_url) {{\n", .{});
    try writer.print("            if (@hasDecl(Servers, \"getUrl\")) {{\n", .{});
    try writer.print("                const server_index = if (@hasField(@TypeOf(options), \"server_index\")) options.server_index else 0;\n", .{});
    try writer.print("                const server_vars = if (@hasField(@TypeOf(options), \"server_vars\")) options.server_vars else .{{}};\n", .{});
    try writer.print("                base_url = try Servers.getUrl(server_index, server_vars, allocator);\n", .{});
    try writer.print("                base_url_owned = base_url;\n", .{});
    try writer.print("            }}\n", .{});
    try writer.print("        }}\n", .{});
    try writer.print("        return .{{ .allocator = allocator, .client = std.http.Client{{ .allocator = allocator }}, .base_url = base_url, .base_url_owned = base_url_owned, .auth_config = auth_config }};\n", .{});
    try writer.print("    }}\n\n", .{});
    try writer.print("    pub fn deinit(self: *Client) void {{\n", .{});
    try writer.print("        self.client.deinit();\n", .{});
    try writer.print("        if (self.base_url_owned) |url| self.allocator.free(url);\n", .{});
    try writer.print("    }}\n\n", .{});

    const methods = [_][]const u8{ "get", "post", "put", "delete", "patch", "options", "head", "trace" };
    const paths = spec.object.get("paths");
    if (paths != null and paths.? == .object) {
        var path_iter = paths.?.object.iterator();
        while (path_iter.next()) |entry| {
            const path_url = entry.key_ptr.*;
            const path_item = entry.value_ptr.*;
            if (path_item == .object) {
                for (methods) |m| {
                    if (path_item.object.get(m)) |op| {
                        try generateOperation(op, path_item, path_url, m, writer, allocator, spec);
                    }
                }
            }
        }
    }
    try writer.print("    fn urlEncode(writer: anytype, input: []const u8) !void {{\n", .{});
    try writer.print("        var w = writer;\n", .{});
    try writer.print("        for (input) |c| {{\n", .{});
    try writer.print("            if (std.ascii.isAlphanumeric(c) or c == '-' or c == '.' or c == '_' or c == '~') {{\n", .{});
    try writer.print("                try w.writeByte(c);\n", .{});
    try writer.print("            }} else if (c == ' ') {{\n", .{});
    try writer.print("                try w.writeByte('+');\n", .{});
    try writer.print("            }} else {{\n", .{});
    try writer.print("                try w.print(\"%%{{X:0>2}}\", .{{c}});\n", .{});
    try writer.print("            }}\n", .{});
    try writer.print("        }}\n", .{});
    try writer.print("    }}\n", .{});
    try writer.print("}};\n\n", .{});
}
fn generateResponseTypes(op_id: []const u8, responses: std.json.Value, writer: anytype, allocator: std.mem.Allocator, spec: std.json.Value) ![]const u8 {
    const camel_op_id = try toCamelCase(allocator, op_id);
    defer allocator.free(camel_op_id);

    // Capitalize first letter for type name
    var type_name_list = std.ArrayList(u8){};
    defer type_name_list.deinit(allocator);

    try type_name_list.append(allocator, std.ascii.toUpper(camel_op_id[0]));
    try type_name_list.appendSlice(allocator, camel_op_id[1..]);
    try type_name_list.appendSlice(allocator, "Response");
    const union_name = try type_name_list.toOwnedSlice(allocator);
    // Note: union_name is owned by caller (or we should manage memory better).
    // Actually, let's just return it and let caller free it, or use an arena.
    // For now, we'll assume caller frees it.

    var response_iter = responses.object.iterator();
    var variants = std.ArrayList([]const u8){};
    defer variants.deinit(allocator);

    while (response_iter.next()) |entry| {
        const code = entry.key_ptr.*;
        const response_def = entry.value_ptr.*;

        // Resolve response if it's a ref
        var response = response_def;
        if (response_def.object.get("$ref")) |ref| {
            if (resolveSchema(spec, ref.string)) |resolved| {
                response = resolved;
            }
        }

        var body_type: ?[]const u8 = null;
        if (response.object.get("schema")) |schema| {
            if (schema.object.get("$ref")) |ref| {
                body_type = try resolveRef(ref.string, 0, allocator);
            } else if (schema.object.get("type")) |t| {
                body_type = try mapType(t.string);
                if (std.mem.eql(u8, t.string, "array")) {
                    if (schema.object.get("items")) |items| {
                        if (items.object.get("$ref")) |ref| {
                            const item_type = try resolveRef(ref.string, 0, allocator);
                            body_type = try std.fmt.allocPrint(allocator, "[]const {s}", .{item_type});
                        } else if (items.object.get("type")) |it| {
                            const item_type = try mapType(it.string);
                            body_type = try std.fmt.allocPrint(allocator, "[]const {s}", .{item_type});
                        }
                    }
                }
            }
        }

        // Generate Struct for this response
        // Name: UnionName + Code (e.g. ReadPodResponse200)
        // Clean up code for identifier (default -> Default)
        var code_suffix_buf: [32]u8 = undefined;
        var code_suffix: []const u8 = undefined;
        if (std.mem.eql(u8, code, "default")) {
            code_suffix = "Default";
        } else {
            code_suffix = try std.fmt.bufPrint(&code_suffix_buf, "{s}", .{code});
        }

        const struct_name = try std.fmt.allocPrint(allocator, "{s}{s}", .{ union_name, code_suffix });
        defer allocator.free(struct_name);

        try writer.print("    pub const {s} = struct {{\n", .{struct_name});
        if (body_type) |bt| {
            try writer.print("        body: {s},\n", .{bt});
        }
        try writer.print("        headers: []const std.http.Header,\n", .{});
        try writer.print("        arena: std.heap.ArenaAllocator,\n", .{});
        try writer.print("    }};\n", .{});

        // Add to variants list
        // Tag: ok (200), created (201), etc. or just code if unknown
        var tag_name: []const u8 = undefined;
        if (std.mem.eql(u8, code, "200")) tag_name = try allocator.dupe(u8, "ok") else if (std.mem.eql(u8, code, "201")) tag_name = try allocator.dupe(u8, "created") else if (std.mem.eql(u8, code, "202")) tag_name = try allocator.dupe(u8, "accepted") else if (std.mem.eql(u8, code, "204")) tag_name = try allocator.dupe(u8, "no_content") else if (std.mem.eql(u8, code, "400")) tag_name = try allocator.dupe(u8, "bad_request") else if (std.mem.eql(u8, code, "401")) tag_name = try allocator.dupe(u8, "unauthorized") else if (std.mem.eql(u8, code, "403")) tag_name = try allocator.dupe(u8, "forbidden") else if (std.mem.eql(u8, code, "404")) tag_name = try allocator.dupe(u8, "not_found") else if (std.mem.eql(u8, code, "default")) tag_name = try allocator.dupe(u8, "default_response") else {
            // Fallback for other codes: code_XYZ
            tag_name = try std.fmt.allocPrint(allocator, "code_{s}", .{code});
        }
        defer allocator.free(tag_name);

        // Store variant definition
        const variant_def = try std.fmt.allocPrint(allocator, "        {s}: {s},", .{ tag_name, struct_name });
        try variants.append(allocator, variant_def);
    }

    // Generate Union
    try writer.print("    pub const {s} = union(enum) {{\n", .{union_name});
    for (variants.items) |v| {
        try writer.print("{s}\n", .{v});
        allocator.free(v);
    }
    try writer.print("    }};\n\n", .{});

    return union_name;
}

fn generateOperation(op: std.json.Value, path_item: std.json.Value, path: []const u8, method: []const u8, writer: anytype, allocator: std.mem.Allocator, spec: std.json.Value) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    const op_id_val = op.object.get("operationId");
    if (op_id_val == null or op_id_val.? != .string) return;
    const op_id = op_id_val.?.string;

    const responses = op.object.get("responses");
    if (responses == null) return;
    const union_name = try generateResponseTypes(op_id, responses.?, writer, arena_allocator, spec);
    // union_name is allocated in arena, no need to free manually

    try writer.print("    pub fn {f}(self: *Client", .{std.zig.fmtId(op_id)});

    // Request Body
    var body_type: ?[]const u8 = null;
    var content_type: []const u8 = "application/json";
    var swagger_body_param_name: ?[]const u8 = null;
    var supports_watch = false;
    var watch_item_type: ?[]const u8 = null;

    if (op.object.get("requestBody")) |rb_val| {
        var rb = rb_val;
        if (rb.object.get("$ref")) |ref| {
            if (resolveSchema(spec, ref.string)) |resolved| {
                rb = resolved;
            }
        }

        if (rb.object.get("content")) |content| {
            if (content.object.get("application/json")) |json_content| {
                content_type = "application/json";
                if (json_content.object.get("schema")) |s| {
                    if (s.object.get("$ref")) |ref| {
                        body_type = try resolveRef(ref.string, 0, arena_allocator);
                    } else if (s.object.get("type")) |t| {
                        if (std.mem.eql(u8, t.string, "array")) {
                            const items = s.object.get("items");
                            if (items != null and items.? == .object) {
                                if (items.?.object.get("$ref")) |ref| {
                                    const item_type = try resolveRef(ref.string, 0, arena_allocator);
                                    body_type = try std.fmt.allocPrint(arena_allocator, "[]const {s}", .{item_type});
                                }
                            }
                        } else {
                            body_type = try arena_allocator.dupe(u8, try mapType(t.string));
                        }
                    }
                }
            } else if (content.object.get("multipart/form-data")) |multipart_content| {
                content_type = "multipart/form-data";
                if (multipart_content.object.get("schema")) |s| {
                    if (s.object.get("$ref")) |ref| {
                        body_type = try resolveRef(ref.string, 0, arena_allocator);
                    }
                }
            } else if (content.object.get("application/x-www-form-urlencoded")) |form_content| {
                content_type = "application/x-www-form-urlencoded";
                if (form_content.object.get("schema")) |s| {
                    if (s.object.get("$ref")) |ref| {
                        body_type = try resolveRef(ref.string, 0, arena_allocator);
                    }
                }
            }
        }
    }

    // Resolve parameters (Path Item + Operation)
    var resolved_params = std.ArrayList(std.json.Value){};
    // Arena will clean up resolved_params items if they were allocated there,
    // but ArrayList itself needs deinit if it allocated backing memory.
    // Since we use arena_allocator for append, we don't strictly need to deinit if arena is deinit'ed,
    // but it's good practice or we can skip it.
    // Actually, if we use arena_allocator, we don't need to deinit lists.

    // 1. Add Path Item parameters (if not overridden)
    if (path_item.object.get("parameters")) |path_params| {
        if (path_params == .array) {
            for (path_params.array.items) |param| {
                var resolved_param = param;
                if (param.object.get("$ref")) |ref| {
                    if (resolveSchema(spec, ref.string)) |resolved| {
                        resolved_param = resolved;
                    }
                }

                // Check if overridden by operation param
                var overridden = false;
                if (op.object.get("parameters")) |op_params| {
                    if (op_params == .array) {
                        for (op_params.array.items) |op_param| {
                            var resolved_op_param = op_param;
                            if (op_param.object.get("$ref")) |ref| {
                                if (resolveSchema(spec, ref.string)) |resolved| {
                                    resolved_op_param = resolved;
                                }
                            }
                            // Compare name and in
                            const p_name = resolved_param.object.get("name").?.string;
                            const p_in = resolved_param.object.get("in").?.string;
                            const op_name = resolved_op_param.object.get("name").?.string;
                            const op_in = resolved_op_param.object.get("in").?.string;

                            if (std.mem.eql(u8, p_name, op_name) and std.mem.eql(u8, p_in, op_in)) {
                                overridden = true;
                                break;
                            }
                        }
                    }
                }

                if (!overridden) {
                    try resolved_params.append(arena_allocator, resolved_param);
                }
            }
        }
    }

    // 2. Add Operation parameters
    const params = op.object.get("parameters");
    if (params != null and params.? == .array) {
        for (params.?.array.items) |param| {
            if (param.object.get("$ref")) |ref| {
                if (resolveSchema(spec, ref.string)) |resolved| {
                    try resolved_params.append(arena_allocator, resolved);
                }
            } else {
                try resolved_params.append(arena_allocator, param);
            }
        }
    }

    // Check for Swagger 2.0 body param
    for (resolved_params.items) |param| {
        if (param.object.get("in")) |in_val| {
            if (std.mem.eql(u8, in_val.string, "body")) {
                if (param.object.get("name")) |name_val| {
                    swagger_body_param_name = name_val.string;
                }
                if (param.object.get("schema")) |s| {
                    if (s.object.get("$ref")) |ref| {
                        body_type = try resolveRef(ref.string, 0, arena_allocator);
                    }
                }
            }
        }
    }

    // Deduplicate parameter names
    var param_names = std.ArrayList([]const u8){};
    var used_param_names = std.StringHashMap(void).init(arena_allocator);
    // defer used_param_names.deinit(); // Arena handles it

    // Reserve 'body' if we have a request body
    if (body_type != null or swagger_body_param_name != null) {
        try used_param_names.put("body", {});
    }

    for (resolved_params.items) |param| {
        if (param.object.get("name")) |name_val| {
            const name = name_val.string;
            var zig_name = try toCamelCase(arena_allocator, name);

            // Check for collision
            if (used_param_names.contains(zig_name)) {
                const in_val = param.object.get("in");
                var suffix: []const u8 = "";
                if (in_val) |iv| {
                    if (std.mem.eql(u8, iv.string, "query")) suffix = "Query" else if (std.mem.eql(u8, iv.string, "path")) suffix = "Path" else if (std.mem.eql(u8, iv.string, "header")) suffix = "Header" else if (std.mem.eql(u8, iv.string, "cookie")) suffix = "Cookie";
                }

                // Try appending suffix
                const new_name = try std.fmt.allocPrint(arena_allocator, "{s}{s}", .{ zig_name, suffix });
                if (!used_param_names.contains(new_name)) {
                    zig_name = new_name;
                } else {
                    // Fallback to numbering
                    var i: usize = 2;
                    while (true) : (i += 1) {
                        const num_name = try std.fmt.allocPrint(arena_allocator, "{s}{d}", .{ zig_name, i });
                        if (!used_param_names.contains(num_name)) {
                            zig_name = num_name;
                            break;
                        }
                    }
                }
            }

            try used_param_names.put(zig_name, {});
            try param_names.append(arena_allocator, zig_name);
        } else {
            // Should not happen for valid params, but handle it
            try param_names.append(arena_allocator, "unknown");
        }
    }

    for (resolved_params.items, 0..) |param, i| {
        if (param.object.get("name")) |name_val| {
            const name = name_val.string;
            const zig_name = param_names.items[i];

            // Skip if this is the Swagger body param (we handle it separately)
            if (swagger_body_param_name) |bp_name| {
                if (std.mem.eql(u8, name, bp_name)) continue;
            }
            // Skip if this is "body" and we have a requestBody (OpenAPI 3)
            if (op.object.get("requestBody") != null and std.mem.eql(u8, name, "body")) continue;

            const schema = param.object.get("schema");
            if (schema != null and schema.? == .object) {
                var zig_type: []const u8 = "[]const u8";
                if (schema.?.object.get("$ref")) |ref| {
                    zig_type = try resolveRef(ref.string, 0, arena_allocator); // Depth 0 for root
                    try writer.print(", {f}: {s}", .{ std.zig.fmtId(zig_name), zig_type });
                } else {
                    if (schema.?.object.get("type")) |t| {
                        zig_type = try mapType(t.string);
                        if (std.mem.eql(u8, t.string, "array")) {
                            if (schema.?.object.get("items")) |items| {
                                if (items.object.get("$ref")) |ref| {
                                    const item_type = try resolveRef(ref.string, 0, arena_allocator);
                                    zig_type = try std.fmt.allocPrint(arena_allocator, "[]const {s}", .{item_type});
                                } else if (items.object.get("type")) |it| {
                                    const item_type = try mapType(it.string);
                                    zig_type = try std.fmt.allocPrint(arena_allocator, "[]const {s}", .{item_type});
                                }
                            }
                        }
                    }
                    try writer.print(", {f}: {s}", .{ std.zig.fmtId(zig_name), zig_type });
                }
            } else {
                // Default to string if no schema
                try writer.print(", {f}: []const u8", .{std.zig.fmtId(zig_name)});
            }
        }
    }

    if (body_type) |bt| {
        try writer.print(", body: {s}", .{bt});
    } else if (swagger_body_param_name) |bp_name| {
        if (body_type) |bt| {
            try writer.print(", {f}: {s}", .{ std.zig.fmtId(bp_name), bt });
        }
    }

    try writer.print(") !{s} {{\n", .{union_name});

    var has_query_params = false;
    for (resolved_params.items) |param| {
        if (param.object.get("in")) |in_val| {
            if (std.mem.eql(u8, in_val.string, "query")) {
                has_query_params = true;
                if (param.object.get("name")) |n| {
                    if (std.mem.eql(u8, n.string, "watch")) {
                        supports_watch = true;
                    }
                }
            }
        }
    }

    try writer.print("    var url_buf: [1024]u8 = undefined;\n", .{});
    try writer.print("    var url_fbs = std.io.fixedBufferStream(&url_buf);\n", .{});
    try writer.print("    const url_w = url_fbs.writer();\n", .{});
    try writer.print("    try url_w.print(\"{{s}}\", .{{ self.base_url }});\n", .{});

    var i: usize = 0;
    while (i < path.len) {
        if (path[i] == '{') {
            const end = std.mem.indexOfPos(u8, path, i, "}");
            if (end) |e| {
                const param_name = path[i + 1 .. e];

                // Find the Zig name for this parameter
                var zig_param_name: []const u8 = "unknown";
                var fmt_spec: []const u8 = "{any}";

                for (resolved_params.items, 0..) |p, idx| {
                    if (p.object.get("name")) |n| {
                        if (std.mem.eql(u8, n.string, param_name)) {
                            // Ensure it's a path param
                            if (p.object.get("in")) |in_v| {
                                if (std.mem.eql(u8, in_v.string, "path")) {
                                    zig_param_name = param_names.items[idx];

                                    var type_str: ?[]const u8 = null;
                                    if (p.object.get("schema")) |s| {
                                        if (s.object.get("type")) |t| {
                                            type_str = t.string;
                                        } else if (s.object.get("$ref")) |ref| {
                                            if (resolveSchema(spec, ref.string)) |resolved| {
                                                if (resolved.object.get("type")) |t| {
                                                    type_str = t.string;
                                                }
                                            }
                                        }
                                    } else if (p.object.get("type")) |t| {
                                        type_str = t.string;
                                    }

                                    if (type_str) |t| {
                                        if (std.mem.eql(u8, t, "string")) fmt_spec = "{s}";
                                        if (std.mem.eql(u8, t, "integer")) fmt_spec = "{d}";
                                        if (std.mem.eql(u8, t, "number")) fmt_spec = "{d}";
                                        if (std.mem.eql(u8, t, "boolean")) fmt_spec = "{}";
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }

                if (std.mem.eql(u8, fmt_spec, "{s}")) {
                    try writer.print("    try urlEncode(url_w, {f});\n", .{std.zig.fmtId(zig_param_name)});
                } else {
                    try writer.print("    try url_w.print(\"{s}\", .{{ {f} }});\n", .{ fmt_spec, std.zig.fmtId(zig_param_name) });
                }
                i = e + 1;
            } else {
                try writer.print("    try url_w.writeByte('{c}');\n", .{path[i]});
                i += 1;
            }
        } else {
            const start = i;
            while (i < path.len and path[i] != '{') i += 1;
            const chunk = path[start..i];
            try writer.print("    try url_w.print(\"{s}\", .{{}});\n", .{chunk});
        }
    }

    if (has_query_params) {
        try writer.print("    var first_query = true;\n", .{});
        try writer.print("    _ = &first_query;\n", .{});
    }

    for (resolved_params.items, 0..) |param, idx| {
        if (param.object.get("name")) |name_val| {
            const name = name_val.string;
            const in_val = param.object.get("in");
            if (in_val != null) {
                if (std.mem.eql(u8, in_val.?.string, "query")) {
                    const zig_name = param_names.items[idx];

                    const schema = param.object.get("schema");
                    if (schema != null) {
                        var is_string_prim = false;
                        var fmt: []const u8 = "{any}";
                        if (schema.?.object.get("type")) |t| {
                            if (std.mem.eql(u8, t.string, "string")) {
                                is_string_prim = true;
                                fmt = "{s}";
                            }
                        }

                        if (is_string_prim) {
                            try writer.print("        if ({f}.len > 0) {{\n", .{std.zig.fmtId(zig_name)});
                            try writer.print("            if (first_query) {{ try url_w.writeByte('?'); first_query = false; }} else {{ try url_w.writeByte('&'); }}\n", .{});
                            try writer.print("            try url_w.print(\"{s}=\", .{{}});\n", .{name});
                            try writer.print("            try urlEncode(url_w, {f});\n", .{std.zig.fmtId(zig_name)});
                            try writer.print("        }}\n", .{});
                        } else {
                            try writer.print("        try url_w.print(\"{s}={{{s}}}\", .{{ {f} }});\n", .{ name, fmt, std.zig.fmtId(zig_name) });
                        }
                    } else {
                        // No schema, treat as string
                        try writer.print("        if ({f}.len > 0) {{\n", .{std.zig.fmtId(zig_name)});
                        try writer.print("            if (first_query) {{ try url_w.writeByte('?'); first_query = false; }} else {{ try url_w.writeByte('&'); }}\n", .{});
                        try writer.print("            try url_w.print(\"{s}=\", .{{}});\n", .{name});
                        try writer.print("            try urlEncode(url_w, {f});\n", .{std.zig.fmtId(zig_name)});
                        try writer.print("        }}\n", .{});
                    }
                }
            }
        }
    }

    try writer.print("        const url = url_fbs.getWritten();\n", .{});

    var method_buf: [16]u8 = undefined;
    const method_upper = std.ascii.upperString(&method_buf, method);

    try writer.print("    var extra_headers = std.ArrayListUnmanaged(std.http.Header){{}};\n", .{});
    try writer.print("    defer extra_headers.deinit(self.allocator);\n", .{});

    // Apply Security
    if (op.object.get("security")) |sec| {
        if (sec == .array) {
            for (sec.array.items) |req_map| {
                if (req_map == .object) {
                    var it = req_map.object.iterator();
                    while (it.next()) |entry| {
                        const scheme_name = entry.key_ptr.*;
                        // Lookup scheme definition
                        if (spec.object.get("components")) |comps| {
                            if (comps.object.get("securitySchemes")) |schemes| {
                                if (schemes.object.get(scheme_name)) |scheme_def| {
                                    const type_val = scheme_def.object.get("type");
                                    if (type_val != null and std.mem.eql(u8, type_val.?.string, "http")) {
                                        const scheme_val = scheme_def.object.get("scheme");
                                        if (scheme_val != null and std.mem.eql(u8, scheme_val.?.string, "bearer")) {
                                            try writer.print("        if (self.auth_config.{f}) |token| {{\n", .{std.zig.fmtId(scheme_name)});
                                            try writer.print("            var auth_buf: [256]u8 = undefined;\n", .{});
                                            try writer.print("            const auth_val = try std.fmt.bufPrint(&auth_buf, \"Bearer {{s}}\", .{{token}});\n", .{});
                                            try writer.print("            try extra_headers.append(self.allocator, .{{ .name = \"Authorization\", .value = auth_val }});\n", .{});
                                            try writer.print("        }}\n", .{});
                                        }
                                    } else if (type_val != null and std.mem.eql(u8, type_val.?.string, "apiKey")) {
                                        const in_val = scheme_def.object.get("in");
                                        const name_val = scheme_def.object.get("name");
                                        if (in_val != null and name_val != null) {
                                            if (std.mem.eql(u8, in_val.?.string, "header")) {
                                                try writer.print("        if (self.auth_config.{f}) |key| {{\n", .{std.zig.fmtId(scheme_name)});
                                                try writer.print("            try extra_headers.append(self.allocator, .{{ .name = \"{s}\", .value = key }});\n", .{name_val.?.string});
                                                try writer.print("        }}\n", .{});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (resolved_params.items, 0..) |param, idx| {
        if (param.object.get("name")) |name_val| {
            const name = name_val.string;
            const in_val = param.object.get("in");
            if (in_val != null) {
                if (std.mem.eql(u8, in_val.?.string, "header")) {
                    const zig_name = param_names.items[idx];
                    try writer.print("        try extra_headers.append(self.allocator, .{{ .name = \"{s}\", .value = {f} }});\n", .{ name, std.zig.fmtId(zig_name) });
                } else if (std.mem.eql(u8, in_val.?.string, "cookie")) {
                    const zig_name = param_names.items[idx];
                    try writer.print("        var cookie_buf: [256]u8 = undefined;\n", .{});
                    try writer.print("        const cookie_val = try std.fmt.bufPrint(&cookie_buf, \"{s}={{s}}\", .{{ {f} }});\n", .{ name, std.zig.fmtId(zig_name) });
                    try writer.print("        try extra_headers.append(self.allocator, .{{ .name = \"Cookie\", .value = cookie_val }});\n", .{});
                }
            }
        }
    }
    try writer.print("        var body_list = std.ArrayListUnmanaged(u8){{}};\n", .{});
    try writer.print("        defer body_list.deinit(self.allocator);\n", .{});
    try writer.print("\n", .{});
    try writer.print("        // Serialize body if present\n", .{});
    try writer.print("        var req_body_writer = std.io.Writer.Allocating.init(self.allocator);\n", .{});
    try writer.print("        defer req_body_writer.deinit();\n", .{});

    if (body_type) |_| {
        try writer.print("        if (@hasDecl(@TypeOf(body), \"validate\")) try body.validate();\n", .{});
        try writer.print("        try std.json.Stringify.value(body, .{{}}, &req_body_writer.writer);\n", .{});
    } else if (swagger_body_param_name) |bp_name| {
        const camel_bp_name = try toCamelCase(arena_allocator, bp_name);
        try writer.print("        if (@hasDecl(@TypeOf({f}), \"validate\")) try {f}.validate();\n", .{std.zig.fmtId(camel_bp_name), std.zig.fmtId(camel_bp_name)});
        try writer.print("        try std.json.Stringify.value({f}, .{{}}, &req_body_writer.writer);\n", .{std.zig.fmtId(camel_bp_name)});
    }

    try writer.print("\n", .{});
    try writer.print("        var write_buf: [4096]u8 = undefined;\n", .{});
    try writer.print("        const ResponseContext = struct {{\n", .{});
    try writer.print("            writer: std.io.Writer,\n", .{});
    try writer.print("            list: *std.ArrayListUnmanaged(u8),\n", .{});
    try writer.print("            allocator: std.mem.Allocator,\n", .{});
    try writer.print("            fn drain(w: *std.io.Writer, chunks: []const []const u8, len: usize) error{{WriteFailed}}!usize {{\n                _ = len;\n                const ctx: *@This() = @fieldParentPtr(\"writer\", w);\n                \n                // Flush existing buffer\n                if (w.end > 0) {{\n                    const buffered = w.buffer[0..w.end];\n                    ctx.list.appendSlice(ctx.allocator, buffered) catch return error.WriteFailed;\n                    w.end = 0;\n                }}\n\n                var total_written: usize = 0;\n                for (chunks) |chunk| {{\n                    if (chunk.len > 0) {{\n                        ctx.list.appendSlice(ctx.allocator, chunk) catch return error.WriteFailed;\n                        total_written += chunk.len;\n                    }}\n                }}\n                return total_written;\n            }}\n", .{});
    try writer.print("        }};\n", .{});
    try writer.print("        const vtable = std.io.Writer.VTable{{ .drain = ResponseContext.drain }};\n", .{});
    try writer.print("        var ctx = ResponseContext{{\n", .{});
    try writer.print("            .writer = std.io.Writer{{ .vtable = &vtable, .buffer = &write_buf, .end = 0 }},\n", .{});
    try writer.print("            .list = &body_list,\n", .{});
    try writer.print("            .allocator = self.allocator,\n", .{});
    try writer.print("        }};\n", .{});
    try writer.print("\n", .{});
    try writer.print("        const fetch_res = try self.client.fetch(.{{\n", .{});
    try writer.print("            .location = .{{ .uri = try std.Uri.parse(url) }},\n", .{});
    try writer.print("            .method = .{s}, // Use format specifier for method\n", .{method_upper});
    try writer.print("            .extra_headers = extra_headers.items,\n", .{});
    try writer.print("            .payload = if (req_body_writer.writer.end > 0) req_body_writer.writer.buffer[0..req_body_writer.writer.end] else null,\n", .{});
    try writer.print("            .response_writer = &ctx.writer,\n", .{});
    try writer.print("        }});\n", .{});
    try writer.print("        \n", .{});
    try writer.print("        // Flush any remaining data in the writer buffer\n", .{});
    try writer.print("        try ctx.writer.vtable.flush(&ctx.writer);\n", .{});
    try writer.print("        \n", .{});
    try writer.print("        // Headers are not available from client.fetch, so we return empty headers for now.\n", .{});
    try writer.print("        // This is a workaround for Zig 0.15.2 std.http.Client limitations/bugs.\n", .{});
    try writer.print("        const headers = try self.allocator.alloc(std.http.Header, 0);\n", .{});
    try writer.print("        var arena = std.heap.ArenaAllocator.init(self.allocator);\n", .{});
    try writer.print("        errdefer arena.deinit();\n", .{});
    try writer.print("\n", .{});
    try writer.print("        const response = struct {{ head: struct {{ status: std.http.Status }} }}{{ .head = .{{ .status = fetch_res.status }} }};\n", .{});
    try writer.writeAll("        switch (response.head.status) {\n");

    var response_iter = responses.?.object.iterator();
    while (response_iter.next()) |entry| {
        const code = entry.key_ptr.*;
        const response_def = entry.value_ptr.*;

        var status_enum: ?[]const u8 = null;
        if (std.mem.eql(u8, code, "200")) status_enum = ".ok" else if (std.mem.eql(u8, code, "201")) status_enum = ".created" else if (std.mem.eql(u8, code, "202")) status_enum = ".accepted" else if (std.mem.eql(u8, code, "204")) status_enum = ".no_content" else if (std.mem.eql(u8, code, "400")) status_enum = ".bad_request" else if (std.mem.eql(u8, code, "401")) status_enum = ".unauthorized" else if (std.mem.eql(u8, code, "403")) status_enum = ".forbidden" else if (std.mem.eql(u8, code, "404")) status_enum = ".not_found" else if (std.mem.eql(u8, code, "default")) {
            // Handled in 'else'
            continue;
        }

        if (status_enum) |s| {
            try writer.print("            {s} => {{\n", .{s});

            // Re-resolve body type
            var resp_body_type: ?[]const u8 = null;
            var resp = response_def;
            if (response_def.object.get("$ref")) |ref| {
                if (resolveSchema(spec, ref.string)) |resolved| {
                    resp = resolved;
                }
            }
            if (resp.object.get("schema")) |schema| {
                if (schema.object.get("$ref")) |ref| {
                    resp_body_type = try resolveRef(ref.string, 0, arena_allocator);
                    if (supports_watch) {
                        if (resolveSchema(spec, ref.string)) |resolved_schema| {
                            if (resolved_schema.object.get("properties")) |props| {
                                if (props.object.get("items")) |items_prop| {
                                    if (items_prop.object.get("type")) |t| {
                                        if (std.mem.eql(u8, t.string, "array")) {
                                            if (items_prop.object.get("items")) |items_schema| {
                                                if (items_schema.object.get("$ref")) |item_ref| {
                                                    watch_item_type = try resolveRef(item_ref.string, 0, arena_allocator);
                                                } else if (items_schema.object.get("type")) |item_t| {
                                                    watch_item_type = try mapType(item_t.string);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (schema.object.get("type")) |t| {
                    resp_body_type = try mapType(t.string);
                    if (std.mem.eql(u8, t.string, "array")) {
                        if (schema.object.get("items")) |items| {
                            if (items.object.get("$ref")) |ref| {
                                const item_type = try resolveRef(ref.string, 0, arena_allocator);
                                resp_body_type = try std.fmt.allocPrint(arena_allocator, "[]const {s}", .{item_type});
                                watch_item_type = item_type;
                            } else if (items.object.get("type")) |it| {
                                const item_type = try mapType(it.string);
                                resp_body_type = try std.fmt.allocPrint(arena_allocator, "[]const {s}", .{item_type});
                            }
                        }
                    }
                }
            }

            // Determine variant name
            var tag_name: []const u8 = undefined;
            if (std.mem.eql(u8, code, "200")) tag_name = "ok" else if (std.mem.eql(u8, code, "201")) tag_name = "created" else if (std.mem.eql(u8, code, "202")) tag_name = "accepted" else if (std.mem.eql(u8, code, "204")) tag_name = "no_content" else if (std.mem.eql(u8, code, "400")) tag_name = "bad_request" else if (std.mem.eql(u8, code, "401")) tag_name = "unauthorized" else if (std.mem.eql(u8, code, "403")) tag_name = "forbidden" else if (std.mem.eql(u8, code, "404")) tag_name = "not_found" else tag_name = "unknown";

            if (resp_body_type) |bt| {
                try writer.print("                const body_resp = try arena.allocator().dupe(u8, body_list.items);\n", .{});
                try writer.print("                const parsed = try std.json.parseFromSliceLeaky({s}, arena.allocator(), body_resp, .{{ .ignore_unknown_fields = true }});\n", .{bt});
                try writer.print("                return .{{ .{s} = .{{ .body = parsed, .headers = headers, .arena = arena }} }};\n", .{tag_name});
            } else {
                try writer.print("                return .{{ .{s} = .{{ .headers = headers, .arena = arena }} }};\n", .{tag_name});
            }
            try writer.print("            }},\n", .{});
        }
    }

    try writer.print("            else => {{\n", .{});
    // Check for default response
    var has_default = false;
    if (responses.?.object.get("default")) |def| {
        has_default = true;
        _ = def;
    }

    if (has_default) {
        try writer.print("                // Handle default response\n", .{});
        // Logic for default response body... similar to above but generic?
        // For now just return default_response with headers
        try writer.print("                return .{{ .default_response = .{{ .headers = headers, .arena = arena }} }};\n", .{});
    } else {
        try writer.print("                std.log.warn(\"Unexpected status code: {{d}}\", .{{response.head.status}});\n", .{});
        try writer.print("                return error.UnexpectedStatus;\n", .{});
    }
    try writer.print("            }}\n", .{});

    try writer.print("        }}\n", .{});
    try writer.print("    }}\n\n", .{});

    if (supports_watch and watch_item_type != null) {
        try writer.print("\n    pub fn watch{f}(self: *Client", .{std.zig.fmtId(op_id)});
        for (resolved_params.items, 0..) |param, param_idx| {
            if (param.object.get("name")) |name_val| {
                const name = name_val.string;
                if (std.mem.eql(u8, name, "watch")) continue; // Skip watch param

                const zig_name = param_names.items[param_idx];
                var type_str: []const u8 = "[]const u8";
                if (param.object.get("schema")) |s| {
                    if (s.object.get("type")) |t| {
                        type_str = try mapType(t.string);
                    } else if (s.object.get("$ref")) |ref| {
                        type_str = try resolveRef(ref.string, 0, arena_allocator);
                    }
                }
                
                if (param.object.get("required")) |req| {
                    if (req == .bool and req.bool) {
                        try writer.print(", {f}: {s}", .{std.zig.fmtId(zig_name), type_str});
                    } else {
                        try writer.print(", {f}: ?{s}", .{std.zig.fmtId(zig_name), type_str});
                    }
                } else {
                    try writer.print(", {f}: ?{s}", .{std.zig.fmtId(zig_name), type_str});
                }
            }
        }
        try writer.print(") !WatchStream({s}) {{\n", .{watch_item_type.?});

        // URL Construction
        try writer.print("        var url_buf: [4096]u8 = undefined;\n", .{});
        try writer.print("        var url_fbs = std.io.fixedBufferStream(&url_buf);\n", .{});
        try writer.print("        const url_w = url_fbs.writer();\n", .{});
        try writer.print("        try url_w.print(\"{{s}}\", .{{ self.base_url }});\n", .{});

        var path_idx: usize = 0;
        while (path_idx < path.len) {
            if (path[path_idx] == '{') {
                if (std.mem.indexOfPos(u8, path, path_idx, "}") != null) {
                     const e = std.mem.indexOfPos(u8, path, path_idx, "}").?;
                    const param_name = path[path_idx + 1 .. e];
                    var zig_param_name: []const u8 = "unknown";
                    var fmt_spec: []const u8 = "{any}";
                    for (resolved_params.items, 0..) |p, idx| {
                        if (p.object.get("name")) |n| {
                            if (std.mem.eql(u8, n.string, param_name)) {
                                zig_param_name = param_names.items[idx];
                                if (p.object.get("schema")) |s| {
                                    if (s.object.get("type")) |t| {
                                        if (std.mem.eql(u8, t.string, "string")) fmt_spec = "{s}";
                                        if (std.mem.eql(u8, t.string, "integer")) fmt_spec = "{d}";
                                    }
                                }
                                break;
                            }
                        }
                    }
                    try writer.print("        try url_w.print(\"{s}\", .{{ {f} }});\n", .{fmt_spec, std.zig.fmtId(zig_param_name)});
                    path_idx = e + 1;
                } else {
                    try writer.writeAll("        try url_w.writeAll(\"{\");\n");
                    path_idx += 1;
                }
            } else {
                const end = std.mem.indexOfPos(u8, path, path_idx, "{") orelse path.len;
                try writer.print("        try url_w.writeAll(\"{s}\");\n", .{path[path_idx..end]});
                path_idx = end;
            }
        }

        // Query Params
        try writer.writeAll("        try url_w.writeAll(\"?watch=true\");\n");
        for (resolved_params.items, 0..) |param, idx| {
            if (param.object.get("in")) |in_val| {
                if (std.mem.eql(u8, in_val.string, "query")) {
                    const name = param.object.get("name").?.string;
                    if (std.mem.eql(u8, name, "watch")) continue; // Skip watch param

                    const zig_name = param_names.items[idx];
                    var fmt_spec: []const u8 = "{any}";
                     if (param.object.get("schema")) |s| {
                        if (s.object.get("type")) |t| {
                            if (std.mem.eql(u8, t.string, "string")) fmt_spec = "{s}";
                            if (std.mem.eql(u8, t.string, "integer")) fmt_spec = "{d}";
                            if (std.mem.eql(u8, t.string, "boolean")) fmt_spec = "{}";
                        }
                    }

                    if (param.object.get("required")) |req| {
                        if (req == .bool and req.bool) {
                             try writer.print("        try url_w.print(\"&{s}={s}\", .{{ {f} }});\n", .{name, fmt_spec, std.zig.fmtId(zig_name)});
                        } else {
                             try writer.print("        if ({f}) |v| try url_w.print(\"&{s}={s}\", .{{ v }});\n", .{std.zig.fmtId(zig_name), name, fmt_spec});
                        }
                    } else {
                         try writer.print("        if ({f}) |v| try url_w.print(\"&{s}={s}\", .{{ v }});\n", .{std.zig.fmtId(zig_name), name, fmt_spec});
                    }
                }
            }
        }


        try writer.print("\n", .{});
        try writer.print("        const req = try self.client.request(.{s}, try std.Uri.parse(url_w.context.getWritten()), .{{ .headers = .{{ .content_type = .{{ .override = \"{s}\" }}, .authorization = if (@hasField(AuthConfig, \"BearerToken\")) if (self.auth_config.BearerToken) |t| .{{ .override = try std.fmt.allocPrint(self.allocator, \"Bearer {{s}}\", .{{t}}) }} else .omit else .omit }} }});\n", .{method_upper, content_type});
        try writer.print("        const heap_req = try self.allocator.create(std.http.Client.Request);\n", .{});
        try writer.print("        heap_req.* = req;\n", .{});
        try writer.print("        errdefer self.allocator.destroy(heap_req);\n", .{});
        try writer.print("        try heap_req.sendBodiless();\n", .{});
        try writer.print("        var header_buf: [4096]u8 = undefined;\n", .{});
        try writer.print("        var res = try heap_req.receiveHead(&header_buf);\n", .{});
        try writer.print("        const transfer_buf = try self.allocator.alloc(u8, 4096);\n", .{});
        try writer.print("        errdefer self.allocator.free(transfer_buf);\n", .{});
        try writer.print("        const reader = res.reader(transfer_buf);\n", .{});
        try writer.print("        return WatchStream({s}){{ .allocator = self.allocator, .req = heap_req, .transfer_buf = transfer_buf, .reader = reader }};\n", .{watch_item_type.?});
        try writer.print("    }}\n\n", .{});
    }
}
fn mapType(json_type: []const u8) ![]const u8 {
    if (std.mem.eql(u8, json_type, "string")) return "[]const u8";
    if (std.mem.eql(u8, json_type, "integer")) return "i64";
    if (std.mem.eql(u8, json_type, "number")) return "f64";
    if (std.mem.eql(u8, json_type, "boolean")) return "bool";
    if (std.mem.eql(u8, json_type, "object")) return "std.json.Value";
    return "[]const u8";
}

fn toCamelCase(allocator: std.mem.Allocator, original: []const u8) ![]const u8 {
    var parts = std.ArrayList([]const u8){};
    defer parts.deinit(allocator);

    var it = std.mem.tokenizeAny(u8, original, "-_.");
    while (it.next()) |part| {
        try parts.append(allocator, part);
    }

    if (parts.items.len == 0) return original;

    var result = std.ArrayList(u8){};
    errdefer result.deinit(allocator);

    for (parts.items, 0..) |part, i| {
        if (i == 0) {
            // First part
            var all_upper = true;
            for (part) |c| {
                if (!std.ascii.isUpper(c) and !std.ascii.isDigit(c)) {
                    all_upper = false;
                    break;
                }
            }

            if (all_upper) {
                for (part) |c| {
                    try result.append(allocator, std.ascii.toLower(c));
                }
            } else {
                // Lowercase only first char
                if (part.len > 0) {
                    try result.append(allocator, std.ascii.toLower(part[0]));
                    for (part[1..]) |c| {
                        try result.append(allocator, c);
                    }
                }
            }
        } else {
            // Titlecase subsequent parts
            if (part.len > 0) {
                try result.append(allocator, std.ascii.toUpper(part[0]));
                for (part[1..]) |c| {
                    try result.append(allocator, std.ascii.toLower(c));
                }
            }
        }
    }

    return result.toOwnedSlice(allocator);
}

test "toCamelCase" {
    const t = std.testing;
    const allocator = t.allocator;

    const s1 = try toCamelCase(allocator, "api-extensions");
    defer allocator.free(s1);
    try t.expectEqualStrings("apiExtensions", s1);

    const s2 = try toCamelCase(allocator, "simple_name");
    defer allocator.free(s2);
    try t.expectEqualStrings("simpleName", s2);

    const s3 = try toCamelCase(allocator, "AlreadyCamel");
    defer allocator.free(s3);
    try t.expectEqualStrings("alreadycamel", s3); // Note: First part lowercased

    const s4 = try toCamelCase(allocator, "io.k8s.api");
    defer allocator.free(s4);
    try t.expectEqualStrings("ioK8sApi", s4);
}

test "mapType" {
    const t = std.testing;
    try t.expectEqualStrings("[]const u8", try mapType("string"));
    try t.expectEqualStrings("i64", try mapType("integer"));
    try t.expectEqualStrings("bool", try mapType("boolean"));
}
